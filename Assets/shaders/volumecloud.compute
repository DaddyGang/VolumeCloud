#pragma kernel CSMain

Texture2D<float4> Source;
RWTexture2D<float4> Destination;

Texture3D<float4> NoiseTex;
Texture3D<float4> DetailNoiseTex;
Texture2D<float4> BlueNoise;
Texture2D<float4> WhetherMap;

SamplerState samplerNoiseTex;
SamplerState samplerDetailNoiseTex;
SamplerState samplerWhetherMap;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float3 _Light;
bool positionLight;

float scale;
float densityMultiplier;
float densityOffset;
float lightAbsorptionTowardSun;
float lightAbsorptionFromCloud;
float darknessThreshold;
float3 params;
float rayOffsetStrength;
float detailNoiseScale;
float detailNoiseWeight;
float3 shapeOffset;
float3 detailOffset;
float3 detailWeights;
float3 detailNoiseWeights;
float4 shapeNoiseWeights;
float4 phaseParams;
int numStepsLight;
float timeScale;
float baseSpeed;
float detailSpeed;

float4 skyBaseColor;
float4 skyTintColor;

static const float maxDst = 500;
static const float epsilon = 0.001f;
static const float shadowBias = epsilon * 50;

struct CloudBox
{
    float3 position;
    float3 size;
};

StructuredBuffer<CloudBox> cbox;

CloudBox box;

struct Ray
{
    float3 origin;
    float3 direction;
};

float SphereDistance(float3 eye, float3 centre, float radius)
{
    return distance(eye, centre) - radius;
}

float CubeDistance(float3 eye, float3 cen, float3 size)
{
    float3 o = abs(eye - cen) - size;
    float ud = length(max(o, 0));
    float n = max(max(min(o.x, 0), min(o.y, 0)), min(o.z, 0));
    return ud + n;
}

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    float3 origin = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0, 1)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin, direction);
}

float GetShapeDistance(CloudBox box, float3 eye)
{
    return CubeDistance(eye, box.position, box.size);
    // return maxDst;
}

// Returns (dstToBox, dstInsideBox). If ray misses box, dstInsideBox will be zero
float2 rayBoxDst(float3 boxpos, float3 boxsize, float3 rayOrigin, float3 invRaydir)
{
    float3 boundsMin = boxpos - boxsize / 2.0f;
    float3 boundsMax = boxpos + boxsize / 2.0f;
    // Adapted from: http://jcgt.org/published/0007/03/04/
    float3 t0 = (boundsMin - rayOrigin) * invRaydir;
    float3 t1 = (boundsMax - rayOrigin) * invRaydir;
    float3 tmin = min(t0, t1);
    float3 tmax = max(t0, t1);
                
    float dstA = max(max(tmin.x, tmin.y), tmin.z);
    float dstB = min(tmax.x, min(tmax.y, tmax.z));

    // CASE 1: ray intersects box from outside (0 <= dstA <= dstB)
    // dstA is dst to nearest intersection, dstB dst to far intersection

    // CASE 2: ray intersects box from inside (dstA < 0 < dstB)
    // dstA is the dst to intersection behind the ray, dstB is dst to forward intersection

    // CASE 3: ray misses box (dstA > dstB)

    float dstToBox = max(0, dstA);
    float dstInsideBox = max(0, dstB - dstToBox);
    return float2(dstToBox, dstInsideBox);
}

float SampleDensity(float3 position)
{
    // Sample Texture in Noise Map
    const int mipmapLevel = 0;
    const float baseScale = 1 / 1000.0f;
    const float offsetSpeed = 1 / 100.0f;
    
    // Calculate texture sample points
    float time = 0.0f * timeScale;
    float3 size = box.size;
    float3 center = box.position;
    float3 uvw = (size * 0.5f + position) * baseScale * scale;
    float3 shapeSamplePos = uvw + shapeOffset * offsetSpeed;
    
    // TODO: Calculate fade off along edges of xz plane
    
    // TODO: Calculate height gradient from weather map
    float heightGradient = 0.5f;
    
    // Calculate base shape density
    float4 shapeNoise = NoiseTex.SampleLevel(samplerNoiseTex, shapeSamplePos, mipmapLevel);
    float4 normalizedShapeWeights = shapeNoiseWeights / dot(shapeNoiseWeights, 1);
    float shapeFBM = dot(shapeNoise, normalizedShapeWeights) * heightGradient;
    float baseShapeDensity = shapeFBM + densityOffset * .1;
    // float4 whetherShape = WhetherMap.SampleLevel(samplerWhetherMap, shapeSamplePos, mipmapLevel);

    return baseShapeDensity;
}

float LightMarch(float3 position)
{
    // March from point on ray
    float3 dirToLight = _Light - position;

    float dstInsideBox = rayBoxDst(box.position, box.size, position, 1 / dirToLight).y;
                
    float stepSize = dstInsideBox / numStepsLight;
    float totalDensity = 0;

    for (int step = 0; step < numStepsLight; step++)
    {
        position += dirToLight * stepSize;
        totalDensity += max(0, SampleDensity(position) * stepSize);
    }

    float transmittance = exp(-totalDensity * lightAbsorptionTowardSun);
    return darknessThreshold + transmittance * (1 - darknessThreshold);
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Destination.GetDimensions(width, height);

    Destination[id.xy] = Source[id.xy];

    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);
    float rayDst = 0;

    Ray ray = CreateCameraRay(uv);
    int marchSteps = 0;
    
    box = cbox[0];

    float2 rayToBoxInfo = rayBoxDst(box.position, box.size, ray.origin, 1.0f / ray.direction);
    float dstToBox = rayToBoxInfo.x;
    float dstInsideBox = rayToBoxInfo.y;
    // Point of entry from ray into the cloud container
    float3 entryPoint = ray.origin + ray.direction * dstToBox;
    
    // TODO: Phase Function
    float dstLimit = min(maxDst - dstToBox, dstInsideBox);
    
    // March through the volume
    float dstTravelled = 0.0f;
    float transmittance = 1.0f;
    float lightEnergy = 0.0f;
    const float STEPSIZE = 0.01f;
    
    float3 rayPos;
    while (dstTravelled < dstLimit)
    {
        rayPos = entryPoint + ray.direction * dstTravelled;
        float density = SampleDensity(rayPos);
        if (density > 0)
        {
            float lightTransmittance = LightMarch(rayPos);
            lightEnergy += density * STEPSIZE * transmittance * lightTransmittance;
            transmittance *= exp(-density * STEPSIZE * lightAbsorptionFromCloud);
            if (transmittance < 0.01f)
            {
                break;
            }
        }
        dstTravelled += STEPSIZE;
    }
    
    float3 bgColor = Source[id.xy];
    float3 LightColor = float3(1, 1, 1);
    float3 cloudColor = lightEnergy * LightColor;
    float3 color = bgColor * transmittance + cloudColor;
    Destination[id.xy] = float4(color, 1.0f);
/*
    while (rayDst < maxDst)
    {
        marchSteps++;
        float4 sceneInfo = SceneInfo(ray.origin);
        float dst = sceneInfo.w;
        
        if (dst <= epsilon)
        {
            float3 pointOnSurface = ray.origin + ray.direction * dst;
            float3 normal = EstimateNormal(pointOnSurface - ray.direction * epsilon);
            float delta = abs(dot(normal, ray.direction));
            float3 lightDir = (positionLight) ? normalize(_Light - ray.origin) : -_Light;
            float lighting = saturate(saturate(dot(normal, lightDir)));
            float3 col = sceneInfo.xyz;
            

            float3 base = col * lighting;
            Destination[id.xy] = Destination[id.xy] * 0.2f + float4(col, 1.0f) * 0.8f;

            break;
        }

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
*/
}
