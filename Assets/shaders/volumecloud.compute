#pragma kernel CSMain

Texture2D<float4> Source;
RWTexture2D<float4> Destination;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

float3 _Light;
bool positionLight;

static const float maxDst = 80;
static const float epsilon = 0.001f;
static const float shadowBias = epsilon * 50;

struct CloudBox
{
    float3 position;
    float3 size;
};

StructuredBuffer<CloudBox> cbox;

struct Ray
{
    float3 origin;
    float3 direction;
};

float SphereDistance(float3 eye, float3 centre, float radius)
{
    return distance(eye, centre) - radius;
}

float CubeDistance(float3 eye, float3 centre, float3 size)
{
    float3 o = abs(eye - centre) - size;
    float ud = length(max(o, 0));
    float n = max(max(min(o.x, 0), min(o.y, 0)), min(o.z, 0));
    return ud + n;
}

float RCubeDistance(float3 eye, float3 centre, float3 size, float r)
{
    float3 o = abs(eye - centre) - size;
    float ud = length(max(o, 0));
    float n = max(max(min(o.x, 0), min(o.y, 0)), min(o.z, 0));
    return ud + n - r;
}

// Following distance functions from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm
float TorusDistance(float3 eye, float3 centre, float r1, float r2)
{
    float2 q = float2(length((eye - centre).xz) - r1, eye.y - centre.y);
    return length(q) - r2;
}

float PrismDistance(float3 eye, float3 centre, float2 h)
{
    float3 q = abs(eye - centre);
    return max(q.z - h.y, max(q.x * 0.866025 + eye.y * 0.5, -eye.y) - h.x * 0.5);
}


float CylinderDistance(float3 eye, float3 centre, float2 h)
{
    float2 d = abs(float2(length((eye).xz), eye.y)) - h;
    return length(max(d, 0.0)) + max(min(d.x, 0), min(d.y, 0));
}

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    float3 origin = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0, 1)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin, direction);
}

// polynomial smooth min (k = 0.1);
// from https://www.iquilezles.org/www/articles/smin/smin.htm
float4 Blend(float a, float b, float3 colA, float3 colB, float k)
{
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    float blendDst = lerp(b, a, h) - k * h * (1.0 - h);
    float3 blendCol = lerp(colB, colA, h);
    return float4(blendCol, blendDst);
}

float4 Combine(float dstA, float dstB, float3 colourA, float3 colourB)
{
    float dst = dstA;
    float3 colour = colourA;

    int operation = 0;
    if (operation == 0)
    {
        if (dstB < dstA)
        {
            dst = dstB;
            colour = colourB;
        }
    }
    // Cut
    else if (operation == 2)
    {
        // max(a,-b)
        if (-dstB > dst)
        {
            dst = -dstB;
            colour = colourB;
        }
    }
    // Mask
    else if (operation == 3)
    {
        // max(a,b)
        if (dstB > dst)
        {
            dst = dstB;
            colour = colourB;
        }
    }
    // Blend mask
    else if (operation == 4)
    {
        
    }

    return float4(colour, dst);
}

float GetShapeDistance(CloudBox box, float3 eye)
{
    return CubeDistance(eye, box.position, box.size);
    // return maxDst;
}


float4 SceneInfo(float3 eye)
{
    float globalDst = maxDst;
    float3 globalColour = 1;
    
    CloudBox box = cbox[0];
    float localDst = GetShapeDistance(box, eye);
    float3 localColour = float3(0, 0, 0);
      
    float4 globalCombined = Combine(globalDst, localDst, globalColour, localColour);
    globalColour = globalCombined.xyz;
    globalDst = globalCombined.w;

    return float4(globalColour, globalDst);
}

float3 EstimateNormal(float3 p)
{
    float x = SceneInfo(float3(p.x + epsilon, p.y, p.z)).w - SceneInfo(float3(p.x - epsilon, p.y, p.z)).w;
    float y = SceneInfo(float3(p.x, p.y + epsilon, p.z)).w - SceneInfo(float3(p.x, p.y - epsilon, p.z)).w;
    float z = SceneInfo(float3(p.x, p.y, p.z + epsilon)).w - SceneInfo(float3(p.x, p.y, p.z - epsilon)).w;
    return normalize(float3(x, y, z));
}

float CalculateShadow(Ray ray, float dstToShadePoint)
{
    float rayDst = 0;
    int marchSteps = 0;
    float shadowIntensity = .2;
    float brightness = 1;

    while (rayDst < dstToShadePoint)
    {
        marchSteps++;
        float4 sceneInfo = SceneInfo(ray.origin);
        float dst = sceneInfo.w;
        
        if (dst <= epsilon)
        {
            return shadowIntensity;
        }

        brightness = min(brightness, dst * 200);

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
    return shadowIntensity + (1 - shadowIntensity) * brightness;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Destination.GetDimensions(width, height);

    Destination[id.xy] = Source[id.xy];

    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);
    float rayDst = 0;

    Ray ray = CreateCameraRay(uv);
    int marchSteps = 0;

    while (rayDst < maxDst)
    {
        marchSteps++;
        float4 sceneInfo = SceneInfo(ray.origin);
        float dst = sceneInfo.w;
        
        if (dst <= epsilon)
        {
            float3 pointOnSurface = ray.origin + ray.direction * dst;
            float3 normal = EstimateNormal(pointOnSurface - ray.direction * epsilon);
            float delta = abs(dot(normal, ray.direction));
            float3 lightDir = (positionLight) ? normalize(_Light - ray.origin) : -_Light;
            float lighting = saturate(saturate(dot(normal, lightDir)));
            float3 col = sceneInfo.xyz;
            

            float3 base = col * lighting;
            Destination[id.xy] = float4(col, 1.0f);

            break;
        }

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
}
